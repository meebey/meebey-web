[[!meta title="TorChat Protocol Dissection"]]
[[!sidebar content="""
[[!toc startlevel=2 levels=2]]
"""]]

***DISCLAIMER: This is NOT a specification but an external _analysis_ of the
TorChat protocol by studying the Java and Python source code implementation of
it which can be found [here][java-source] and [here][python-source].*** I am
_not_ related to the Tor or [TorChat][] projects. I simply try to cover the
protocol as correctly as possible but don't cry if it contains errors or is
incomplete. I am using this as base for a C# based implementation for use in the
[Smuxi Messenger][smuxi].

  [java-source]: https://github.com/prof7bit/TorChat-Android/blob/master/TorChat/src/prof7bit/torchat/core/ "TorChat's Java source code"
  [python-source]: https://github.com/prof7bit/TorChat/blob/torchat_py/torchat/src/tc_client.py "TorChat's Python source code"
  [TorChat]: https://github.com/prof7bit/TorChat
  [smuxi]: https://www.smuxi.org/

## Transport ##

Uses TCP sockets to hidden services running on port 11009.

Peers send and receive messages on that TCP socket.

## Connections ##

Hidden services behave like regular server sockets except that the server has no
idea who (in the sense of IP source address) the client is because it is a tor
client. As TorChat is p2p, it needs to make out-bound connections to send
messages _and_ allow in-bound connections to receive messages from other peers.
Both in- and out-bound connections always happen on port 11009.

### Out-Bound Connections ###

Connections to TorChat peers (the hidden service on port 11009) are out-bound
and are authenticated by definition as only the owner of the hidden service key
is able to respond to the connection attempt.

### In-Bound Connections ###

Connections from other TorChat peers are always _unauthenticated_ except they
can prove in some way that they are who they pretent to be. TorChat uses an
session token for each peer to authenticate their connection and only then we
can believe the claimed origin of the messages we receive on that in-bound
connection. For more details how this authentication procedure works refer to
the _Authentication_ section below.

## Message Format ##

 * type: byte array
 * message seperator: 0x0a (LF)
 * decode as string:
   * replace '\r\n' with '\n' then '\n' with "\n" (LF)

## Message Commands ##

### ping ###

Format:

    ping <hidden_service_id> <session_token>

&lt;hidden_service_id&gt; is the hash of the public key used in the onion
network.

&lt;token&gt; is an arbitrary sized session token that the receiver must return
in the pong command (see below) to prove the autentication of the connection.

***WARNING: this session token has to be kept secret as this is the session key
of the authenticated connection!*** If this token leaks, anyone can impersonate
the identity of that hidden service / TorChat peer as long as the TorChat
application which generated this token runs.

Example:

    ping mb4bc4jk4cj2fky4 31754944747097474078662100165902771331350515775810664422385852963171834014133

### pong ###

### client ###

### version ####

### add_me ###

### message ###

### status ###

Format:

    status <status>

&lt;status&gt; can be one of:

 * away
 * available
 * xa

Example:

    status available

### filename ###

### filedata ###

### filedata_ok ###

## Authentication / Handshake ##

TBD

## Potential Security Issues / Weaknesses ##

### Hidden Services ###

Tor's hidden services fully rely on 1024 bit RSA keys. I don't know yet how
these keys are used to make a conclusion if this is a real weakness or not.

### Authentication Tokens ###

The TorChat client that wants to authenticate an hidden service hashkey (which
is a chat buddy / peer in TorChat) has to generate an authentication token that
the chat peer needs to return. If the client selects a weak token, say a pretty
short one or one without real random data, then the token could be guessed and
you could send spoofed TorChat messages that look like they are coming from the
authenticated peer.
